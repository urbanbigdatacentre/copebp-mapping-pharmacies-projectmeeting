---
title: "COPE-BP Annual Meeting - WP1 mapping clusters"
author: "Diego Pajarito"
date: "2025-12-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## COPE-BP Mapping Clusters Markdown document

This R Markdown document is designed for sharing resources at the Annual meeting and contain analysis of fieldwork and survey data prepared within the WP1.

This document is automatically generated using the option **Knit** within an R-Markdown file. Therefore some content might not display correctly. Please contact the [Diego Pajarito Grajales](mailto:Diego.PajaritoGrajales@glasgow.ac.uk) for any additional requirement.

### Initial setup

The workflow uses different libraries such as **haven** and **readxl** for data management as well as [sf](https://r-spatial.github.io/sf/), **dplyr** and [leaflet](https://leafletjs.com) for geospatial data management.

```{r packages, include=FALSE}
# This is only needed once and in environments where the packages are not available
#install.packages("haven") # Required to process data files
#install.packages("readxl") # Required to process excell file
#install.packages("leaflet.extras")
```

```{r libraries, include=FALSE}
library(haven)
library(readxl)
library(sf)
library(leaflet)
library(leaflet.extras)
library(dplyr)
library(tidyr)
library(ggplot2)
library(stringr)
```



```{r read_data, include=FALSE}
pk_data <- read_dta("Survey-v2/02_PCS/03_database/04_cleandata/COPE-BP_PK_PCQ.dta")

# For Bangladesh, at the moment, geospatial data is not integrated due to some missing values for location
bd_data <- read_dta("Survey-v2/02_PCS/03_database/04_cleandata/COPE-BP_BD_PCQ.dta")
bd_data_geo <- read_excel("Survey-v2/02_PCS/03_database/01_preload/pk_pharmacy_list.xlsx", sheet="Bangladesh Pharmacy Data")
```


```{r set_geometry, include=FALSE}
# First we need to add geometries to the data set. We use the values in coordinates stored as columns.
# This uses a full join to only treat the data with known location

bd_data_geo <- merge(bd_data, bd_data_geo, by.x = "_id", by.y = "_id")

bd_data_geo <- bd_data_geo %>%
  st_as_sf(coords = c("_location_longitude", "_location_latitude"), 
           crs = 4326,
           remove = FALSE)  # Keeps original columns

pk_data_geo <- pk_data %>%
  st_as_sf(coords = c("_location_longitude", "_location_latitude"), 
           crs = 4326,
           remove = FALSE)  # Keeps original columns

```

## Analysing catchment areas as strata for defining clusters

One first option to cluster pharmacies is based on geographies and locations. This initial setup uses the k-means method to visualise how this cluster is peformed. 

Using data form the city of Dhaka, we 

In order to visualise the geospatial location of the surveyed facilities, there is an option to merge mapping data and survey data. This is done using the merge option 



**Geospatial clusters in Bangladesh**
This map might miss some of the mapped pharmacies found after the initial screening. This will be updated in future versions of this file.


**Clusters based on catchment areas**
Despite their location, some pharmacies might serve population from different areas in the city. The survey asks broadly where the clients come from. We use this information to understand how this would serve for the sampling design and pharmacy clusters.

We reorganised the original data to identify the areas/neighbourhoods/union councils/wards the clients come from.

### **Bangladesh**
```{r db_select_pharmacies_client_areas, include=FALSE}
bd_pharm_clients <- bd_data_geo %>% 
  filter(pq_consent ==1) %>%   # Select only eligible pharmacies
  select("_id", "pq_city", "pq_ward", starts_with("pq_c_area"), "geometry")

# There are some other notes about clients that are stored as free text
# this will be analysed independently
bd_pharm_clients_text <- bd_pharm_clients %>% 
  select("_id", "pq_city", "pq_ward", "pq_c_area_oth", "geometry") %>% 
  filter (!is.na("pq_c_area_oth"))

# Firs step is to combine all the values captured as columns in a different rows
bd_pharm_count_wards <- bd_pharm_clients %>% 
  select(-"pq_c_area_oth") %>% pivot_longer(
  col = starts_with("pq_c_area_"),
  names_to = ("catch_area"),
  values_to = ("count_catch"),
  names_prefix = "area_"
)
```

The areas were captured as codded values, so we mapped them with their labels to improve readability.


```{r bd_lables_areas,  include=FALSE}
type_cities <- c(
  "1" = "Dhaka North City Corporation (DNCC)",
  "2" = "Dhaka South City Corporation (DSCC)",
  "3" = "Narsingdi Paurashava",
  "4" = "Ghorashal Paurashava"
)

type_areas <- c(
  "pq_c_area_dncc___11" = "DNCC Ward 5",
  "pq_c_area_dncc___12" = "DNCC Ward 11",
  "pq_c_area_dncc___13" = "DNCC Ward 13",
  "pq_c_area_dncc___14" = "DNCC Ward 15 (Part)",
  "pq_c_area_dncc___15" = "DNCC Ward 16",
  "pq_c_area_dncc___16" = "DNCC Ward 19 (Part)",
  "pq_c_area_dncc___17" = "DNCC Ward 20 (Part)",
  "pq_c_area_dncc___18" = "DNCC Ward 23",
  "pq_c_area_dncc___19" = "DNCC Ward 34 (Part)",
  "pq_c_area_dncc___98" = "DNCC Others",
  "pq_c_area_dncc___97" = "DNCC Do not know",
  "pq_c_area_dscc___21" = "DSCC Ward 12",
  "pq_c_area_dscc___22" = "DSCC Ward 22",
  "pq_c_area_dscc___23" = "DSCC Ward 33",
  "pq_c_area_dscc___24" = "DSCC Ward 57",
  "pq_c_area_dscc___25" = "DSCC Ward 60",
  "pq_c_area_dscc___26" = "DSCC Ward 71",
  "pq_c_area_dscc___98" = "DSCC Others",
  "pq_c_area_dscc___97" = "DSCC Do not know",
  "pq_c_area_nar___31" = "NP Ward 1",
  "pq_c_area_nar___32" = "NP Ward 8",
  "pq_c_area_nar___98" = "NP Others",
  "pq_c_area_nar___97" = "NP Do not know",
  "pq_c_area_ghor___41" = "GP Ward 2",
  "pq_c_area_ghor___42" = "GP Ward 3",
  "pq_c_area_ghor___43" = "GP Ward 6",
  "pq_c_area_ghor___44" = "GP Ward 7",
  "pq_c_area_ghor___98" = "GP Others",
  "pq_c_area_ghor___97" = "GP Do not know"
)


bd_pharm_count_wards <- bd_pharm_count_wards %>% 
  mutate(city = type_cities[as.character(pq_city)]) %>% 
  mutate(area = type_areas[as.character(catch_area)])
```

This is an example of how the values were coded: 

```{r bd_label_areas_show, results='markup'}
type_cities

```

While the majority of pharmacies report a single area as the one where their clients come from, there are some others that report additional ones. We can see the proportion of these in the following plot. We will continue analysing those pharmacies that report clients coming from additional areas.


```{r bd_plot_pharmacies_clients_areas, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}
# We group all the values and count the different areas reported

bd_pharm_total_areas <- bd_pharm_count_wards %>% 
  rename("idpharm" = "_id") %>% 
  filter(count_catch == 1) %>% 
  group_by(idpharm, pq_city, city, pq_ward, geometry) %>% 
  summarise(count = n(),
            total_areas = sum(count_catch, na.rm = TRUE)
            )

# Vertical bars
ggplot(bd_pharm_total_areas, aes(x = total_areas)) +
  geom_histogram() +
  facet_wrap(~city) +
  labs(
    title = "Pakistan - Areas where clients come from ",
    x = "Number of dreas reported by pharmacies.",
    y = "Count of pharmacies"
  ) +
  theme_minimal()
```



When detailing how these pharmacies reporting their clients coming from other areas refer to those sites, we find that the survey capture pharmacies reporting clients coming from areas out of our study areas (e.g., Others) or unknown areas (e.g., I don't know). The plot below shows that not all reported locations are known and this would make isolating pharmacies based on the origin of their clients to prevent cross contamination more difficult. 

Note: This analysis does not consider those locations reported as a free text in the survey. This require additional case-specific analysis.

```{r bd_pharm_multi_areas, include=FALSE}
# We group all the values and count the different areas reported
bd_pharm_multi_area <- bd_pharm_count_wards %>% 
  filter(!str_ends(catch_area, as.character(pq_ward))) %>% 
  filter(count_catch > 0)

bd_pharm_multi_area <- bd_pharm_multi_area %>% 
  rename("pharmid"= "_id")
```

```{r bd_pharm_multi_areas_location,  include=FALSE}

bd_pharm_multi_area <- bd_pharm_multi_area %>%
  mutate(location = case_when(
    str_ends(catch_area, "98") ~ "Other",
    str_ends(catch_area, "97") ~ "Unknown",
    TRUE ~ "Known"
  ))

```

```{r bd_pharm_single_areas, include=FALSE}
bd_pharm_single_area <- bd_pharm_count_wards %>% 
  filter(str_ends(catch_area, as.character(pq_ward)) & !"_id" %in% bd_pharm_multi_area$pharmid )
bd_pharm_single_area <- bd_pharm_single_area %>% 
  rename("pharmid"= "_id")

```

```{r bd_pharm_multi_areas_location_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}
# Horizontal bars
ggplot(bd_pharm_multi_area, aes(y = city, fill=location)) +
  geom_bar() +
  #facet_wrap(~city) +
  labs(
    title = "Bangladesh - Clients from other area",
    x = "Count of locations",
    y = "",
    fill = "Reported location"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

Still it is possible to work with the subset of pharmacies i) reporting clients coming form a different area and ii) reporting a known location. We use a visualisation technique to link each pharmacy and the reported location to understand the spatial relationships between the pharmacy and the catchment area. 
Note: This analysis focuses on those links with areas different to the one the pharmacy is located at. It is safe to assume that all pharmacies serve clients from the area they are located.

Note: that the team did not obtain admin boundaries for "Ghorashal Paurashava"




```{r bg_map_pharm_zones, echo=FALSE}
# Classifying pharmacies into those reporting areas where their clients come from as different from the one it is located


color_loc <- colorFactor(
  palette = c("darkgreen",  "darkred"),
  domain = bd_pharm_multi_area$location
)

leaflet() %>%
  addTiles(group = "OpenStreetMap") %>%  # Add base map
  addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
  addCircles(
    data = bd_pharm_single_area,
    weight =  1.8,
    color = "red",
    fillOpacity = 0.9,
    stroke = TRUE,
    popup = ~paste("_id:", pharmid),
    group = "Pharmacies"
  ) %>%
  addCircleMarkers(
    data = bd_pharm_multi_area,
    color = ~color_loc(location),
    radius = 2.8,
    fillOpacity = 0.6,
    popup = ~paste("_id: ", as.character(pharmid), " & Rep. Location:", location),
    group = "Parmacies with clients in other Area"
  ) %>% 
  addLegend(
    "bottomright",
    pal = color_loc,
    values = bd_pharm_multi_area$location,
    title = "Location where client come from"
  ) %>% 
  # Add layers control (toggle and radio)
  addLayersControl(
    baseGroups = c("OpenStreetMap", "Satellite"),
    overlayGroups = c("Pharmacies", "Parmacies with clients in other Area"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addFullscreenControl()

```







### **Pakistan**
```{r pk_select_pharmacies_client_areas, include=FALSE}
# For Pakistan all pharmacies are eligible
pk_pharm_clients <- pk_data_geo %>% 
  select("_id", "pq_city", "pq_ward", starts_with("pq_c_area"), "geometry")

# There are some other notes about clients that are stored as free text
# this will be analysed independently
pk_pharm_clients_text <- pk_pharm_clients %>% 
  select("_id", "pq_city", "pq_ward", "pq_c_area_oth", "geometry") %>% 
  filter (!is.na("pq_c_area_oth"))

# Firs step is to combine all the values captured as columns in a different rows
pk_pharm_areas <- pk_pharm_clients %>% 
  select(-"pq_c_area_oth") %>% pivot_longer(
  col = starts_with("pq_c_area_"),
  names_to = ("catch_area"),
  values_to = ("count_catch"),
  names_prefix = "area_"
)
```

The areas were captured as codded values, so we mapped them with their labels to improve readability.


```{r pk_label_areas,  include=FALSE}
type_cities <- c(
  "1" = "Peshawar",
  "2" = "Abbottabad"
)

type_areas <- c(
  "pq_c_area_pes___101" = "Hassan Garhi",
  "pq_c_area_pes___102" = "Palosi",
  "pq_c_area_pes___103" = "Pawaka",
  "pq_c_area_pes___104" = "Regi",
  "pq_c_area_pes___105" = "Sufaid Dheri",
  "pq_c_area_pes___106" = "Tehkal Bala",
  "pq_c_area_pes___107" = "Tehkal Payan 1",
  "pq_c_area_pes___108" = "Tehkal Payan 2",
  "pq_c_area_pes___109" = "UC Malakandher",
  "pq_c_area_pes___110" = "UC Shaheen Town",
  "pq_c_area_pes___111" = "University Town", 
  "pq_c_area_pes___98" = "GP Others",
  "pq_c_area_pes___97" = "GP Do not know",
  "pq_c_area_abt___212" = "Baldhari",
  "pq_c_area_abt___213" = "Jhangi",
  "pq_c_area_abt___214" = "Malikpura",
  "pq_c_area_abt___215" = "Mirpur",
  "pq_c_area_abt___216" = "Shaikul Bandi",
  "pq_c_area_abt___217" = "UC Nawansher",
  "pq_c_area_abt___97" = "AB Do not know",
  "pq_c_area_abt___98" = "AB Others",
  "pq_c_area_ghor___98" = "GP Others",
  "pq_c_area_ghor___97" = "GP Do not know"
)

pk_pharm_count_areas <- pk_pharm_areas %>% 
  mutate(city = type_cities[as.character(pq_city)]) %>% 
  mutate(area = type_areas[as.character(catch_area)])
```

This is an example of how the values were coded: 

```{r bg_lables_areas_show, results='markup'}
type_cities

```

In Pakistan multiple pharmacies report more areas where their clients come from. We can see the proportion of these in the following plot as a wider variety. We will continue analysing those pharmacies that report clients coming from additional areas.


```{r pk_plot_pharmacies_clients_areas, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}
# We group all the values and count the different areas reported

pk_pharm_total_areas <- pk_pharm_count_areas %>% 
  rename("idpharm" = "_id") %>% 
  filter(count_catch == 1) %>% 
  group_by(idpharm, pq_city, city, pq_ward, geometry) %>% 
  summarise(count = n(),
            total_areas = sum(count_catch, na.rm = TRUE)
            )

# Horizontal bars
ggplot(pk_pharm_total_areas, aes(x = total_areas)) +
  geom_histogram() +
  facet_wrap(~city) +
  labs(
    title = "Pakistan - Areas where clients come from ",
    x = "Number of dreas reported by pharmacies.",
    y = "Count of pharmacies"
  ) +
  theme_minimal()
```



As in Bangladesh, pharmacies reporting clients coming from more areas different from where they are located. The plot below shows that not all reported locations are known and this would make isolating pharmacies based on the origin of their clients to prevent cross contamination more difficult. 

Note: This analysis does not consider those locations reported as a free text in the survey. This require additional case-specific analysis.

```{r pk_pharm_multi_areas, include=FALSE}
# We group all the values and count the different areas reported
pk_pharm_multi_area <- pk_pharm_count_areas %>% 
  filter(!str_ends(catch_area, as.character(pq_ward))) %>% 
  filter(count_catch > 0)

pk_pharm_multi_area <- pk_pharm_multi_area %>% 
  rename("pharmid"= "_id")
```

```{r pk_pharm_multi_areas_location,  include=FALSE}

pk_pharm_multi_area <- pk_pharm_multi_area %>%
  mutate(location = case_when(
    str_ends(catch_area, "98") ~ "Other",
    str_ends(catch_area, "97") ~ "Unknown",
    TRUE ~ "Known"
  ))

```

```{r pk_pharm_single_areas, include=FALSE}
pk_pharm_single_area <- pk_pharm_count_areas %>% 
  filter(str_ends(catch_area, as.character(pq_ward)) & !"_id" %in% pk_pharm_multi_area$pharmid )

pk_pharm_single_area <- pk_pharm_single_area %>% 
  rename("pharmid"= "_id")

```

```{r pk_pharm_multi_areas_location_plot, echo=FALSE, message=FALSE, warning=FALSE, fig.align='center'}
# Horizontal bars
ggplot(pk_pharm_multi_area, aes(y = city, fill=location)) +
  geom_bar() +
  #facet_wrap(~city) +
  labs(
    title = "Pakistan - Clients from other area",
    x = "Count of locations",
    y = "",
    fill = "Reported location"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```


In this case, there are just a few pharmacies reporting unknown areas where their clients come from. It is feasible to analyse the links between the pharmacies and the reported known location. We use a visualisation technique to link each pharmacy and the reported location to understand the spatial relationships between the pharmacy and the catchment area. 
Note: This analysis focuses on those links with areas different to the one the pharmacy is located at. It is safe to assume that all pharmacies serve clients from the area they are located.

Note: Some of the areas were mapped to bigger divisions than the ones recorded in the survey (e.g., Hassan Garhi I, Malikpura)


```{r pk_geo_uc_filter, include=FALSE}
# For Bangladesh, at the moment, geospatial data is not integrated due to some missing values for location
pk_uc <- st_read("Reference-data/pak_admbnda_union_council.geojson")
pk_uc <- pk_uc %>% 
  filter(!is.na(survey_code)) %>% 
  select(TEHSIL, UC, UC_NAME, survey_code, geometry)

```


```{r pk_geo_function_curves, include=FALSE}

# A function to generate arc as lines
create_arc <- function(from_point, to_point, n_points = 50) {
  from_coords <- st_coordinates(from_point)
  to_coords <- st_coordinates(to_point)
  
  # Create bezier-like curve
  t <- seq(0, 1, length.out = n_points)
  
  # Calculate midpoint with elevation for arc effect
  mid_x <- (from_coords[1] + to_coords[1]) / 2
  mid_y <- (from_coords[2] + to_coords[2]) / 2
  
  # Add curvature
  curve_height <- 0.01  # Adjust for more/less curve
  
  x_curve <- from_coords[1] * (1-t)^2 + 
             2 * mid_x * (1-t) * t + 
             to_coords[1] * t^2
  
  y_curve <- from_coords[2] * (1-t)^2 + 
             2 * (mid_y + curve_height) * (1-t) * t + 
             to_coords[2] * t^2
  
  st_linestring(cbind(x_curve, y_curve))
}

# Extract the coded areas in the survey data. These are stored as the ending text of column names
pk_pharm_multi_area$client_area <- as.integer(substr(pk_pharm_multi_area$catch_area, nchar(pk_pharm_multi_area$catch_area) - 3 + 1, nchar(pk_pharm_multi_area$catch_area)))



```

```{r pk_geo_build_curves, warning=FALSE, include=FALSE}


# Remove rows where the client area is not identified
pk_pharm_areas <- pk_pharm_multi_area %>% 
  filter(!is.na(client_area))

pk_pharm_areas_arcs <- st_sf(pharmid = character(),
  survey_code = character(),
  geometry = st_sfc(crs = 4326))

for(i in 1:nrow(pk_pharm_areas)) {
  # Get value of pacient area
  areacode <- pk_pharm_areas[i,]$client_area
  
  # Find the referred uc
  match_uc <- pk_uc %>% 
    filter(survey_code == areacode)
  
  new_row <- st_sf(
    pharmid = pk_pharm_areas[i,]$pharmid,
    survey_code = match_uc$survey_code,
    geometry = st_sfc(create_arc(pk_pharm_areas[i,], st_centroid(match_uc), 50), crs = 4326)
  )

  pk_pharm_areas_arcs <- rbind(pk_pharm_areas_arcs, new_row)
}


```

  


```{r pk_map_pharm_zones, echo=FALSE}
# Classifying pharmacies into those reporting areas where their clients come from as different from the one it is located


color_loc <- colorFactor(
  palette = c("darkgreen",  "darkred"),
  domain = pk_pharm_multi_area$location
)

leaflet() %>%
  addTiles(group = "OpenStreetMap") %>%  # Add base map
  addProviderTiles(providers$Esri.WorldImagery, group = "Satellite") %>%
  addCircles(
    data = pk_pharm_single_area,
    weight =  1.8,
    color = "red",
    fillOpacity = 0.9,
    stroke = TRUE,
    popup = ~paste("_id:", pharmid),
    group = "Pharmacies"
  ) %>%
  addCircleMarkers(
    data = pk_pharm_multi_area,
    color = ~color_loc(location),
    radius = 2.8,
    fillOpacity = 0.6,
    popup = ~paste("_id: ", as.character(pharmid), " & Rep. Location:", location),
    group = "Parmacies with clients in other Area"
  ) %>% 
  addPolylines(
    data = pk_pharm_areas_arcs,
    group = "Pharmacy arc links",
    color = "darkgreen",
    fill = FALSE,
    stroke = TRUE,
    weight = 0.4
  ) %>% 
  addLegend(
    "bottomright",
    pal = color_loc,
    values = pk_pharm_multi_area$location,
    title = "Location where client come from"
  ) %>% 
  # Add layers control (toggle and radio)
  addLayersControl(
    baseGroups = c("OpenStreetMap", "Satellite"),
    overlayGroups = c("Pharmacies", "Parmacies with clients in other Area", "Pharmacy arc links"),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
  addFullscreenControl()

```